\section{Details of the formalization}

\subsection{32 replacement instances to rule them all}
\label{sec:repl-instances}

We isolated 32 instances of Replacement that are sufficient to force
$\CH$ or $\neg\CH$. The first 13 instances are needed to set up
cardinal arithmetic in $M$. Many of these were already present in
relational form in the \session{ZF-Constructible} library.

\begin{itemize}
\item 6 instances for iteration of operations (between parentheses). For each construct,
  Paulson used one replacement instance in order to have absoluteness,
  and a second one to obtain closure.
  \begin{itemize}
  \item
    \isatt{list{\uscore}repl1{\uscore}intf{\uscore}fm} and 
    \isatt{list{\uscore}repl2{\uscore}intf{\uscore}fm}.
    
    For lists on a set $A$ ($X\mapsto \{0 \} \oplus A \times X$, where
    $D\oplus E$ stands for the disjoint union/coproduct $(\{0 \}\times
    D) \cup (\{1 \}\times E)$).
    %
  \item
    \isatt{formula{\uscore}repl1{\uscore}intf{\uscore}fm} and
    \isatt{formula{\uscore}repl1{\uscore}intf{\uscore}fm}.
    
    For (codes of) first order formulas ($X\mapsto (\omega \times
    \omega \oplus \omega \times \omega) \oplus X \times X \oplus X$).
    %
  \item
    \isatt{eclose{\uscore}repl1{\uscore}intf{\uscore}fm} and 
    \isatt{eclose{\uscore}repl2{\uscore}intf{\uscore}fm}.

    For transitive closure ($X\mapsto\union X$).
  \end{itemize}
\item \isatt{tl{\uscore}repl{\uscore}intf{\uscore}fm}

  Absoluteness of the definition of the
  $n$th element of a list (iteration of the tail operation).
  By transitivity, we do not need an instance for closure.
\end{itemize}
The instances so far
are needed to interpret locales \isatt{M{\uscore}datatypes} and
\isatt{M{\uscore}eclose}. The former is used in the relative definition of
\isatt{Vset}.
\begin{itemize}
\item
  2 instances for ordertypes.
  \begin{itemize}
  \item
    \isatt{replacement{\uscore}is{\uscore}order{\uscore}eq{\uscore}map{\uscore}fm}.

    Auxiliary instance for the definition of ordertypes, needed for
    the interpretation of \isatt{M{\uscore}ordertype}.
    %
  \item
    \isatt{replacement{\uscore}is{\uscore}order{\uscore}body{\uscore}fm}.

    Replacement through $x\mapsto \otype(x)$, for Hartogs' Theorem.
  \end{itemize}
\item
  4 instances for definitions by well-founded recursion.
  \begin{itemize}
  \item \isatt{wfrec{\uscore}replacement{\uscore}order{\uscore}pred{\uscore}fm}.

    For ordertypes
    %
  \item \isatt{wfrec{\uscore}rank{\uscore}fm}.

    For $\in$-rank.
    %
  \item \isatt{trans{\uscore}repl{\uscore}HVFrom{\uscore}fm}.

    For the cumulative hierarchy (rank initial segments).
    %
  \item
    \isatt{replacement{\uscore}HAleph{\uscore}wfrec{\uscore}repl{\uscore}body{\uscore}fm}.

    For Aleph.
  \end{itemize}
\end{itemize}

We also need a one extra replacement instance $\psi$ on $M$ for each
$\phi$ of the
previous ones to have them in $M[G]$.
\[
  \psi(x,\alpha,y_1,\dots,y_n) \defi \quine{\alpha = \min \bigl\{
    \beta \mid \exists\tau\in V_\beta.\  \mathit{snd}(x) \forces
    \phi\ [\mathit{fst}(x),\tau,y_1,\dots,y_n]\bigr\}}
\]
Here, $\mathit{fst}(\lb a,b\rb) = a$, $\mathit{snd}(\lb a,b\rb) = b$
(with default value $0$ for non pairs).
In our development, the mapping $\phi\mapsto\psi$ defined above is given by the
$\isatt{ground{\uscore}repl{\uscore}fm}$ function, and all ground replacement
instances appear in the locale \isatt{M{\uscore}ZF4}. These are expressed using
the \isatt{ground{\uscore}replacement{\uscore}assm(M,\isasymphi)} predicate
obtained by replacing $\phi$ by
$\isatt{ground{\uscore}repl{\uscore}fm}(\phi)$ in Eq.~(\ref{eq:replacement_assm_def}).

That makes 26 instances up to now. For the setup of forcing, we
require the following 5 instances (the last two are needed for the $\Delta$-System Lemma):

\begin{itemize}
\item 2 instances for definitions by well-founded recursion.
  \begin{itemize}
  \item \isatt{wfrec{\uscore}Hcheck{\uscore}fm}.

    For check-names.
    %
  \item \isatt{wfrec{\uscore}Hfrc{\uscore}at{\uscore}fm}.

    Definition of forcing for atomic formulas.
  \end{itemize}
  %
\item
  \isatt{Lambda{\uscore}in{\uscore}M{\uscore}fm(check{\uscore}fm(2,0,1),1)}.

  Replacement through $x\mapsto \lb x,\check{x}\rb$ (for the
  definition of $\punto{G}$).
  %
\item
  \isatt{replacement{\uscore}is{\uscore}trans{\uscore}apply{\uscore}image{\uscore}fm}.

  Recursive construction of sets using a choice function (as in the
  construction of a wellorder of $X$ given a choice function on $\Pow(X)$).
  %
\item
  \isatt{replacement{\uscore}transrec{\uscore}apply{\uscore}image{\uscore}body{\uscore}fm}.

  Absoluteness of the previous construction.
\end{itemize}
%
This is enough to force $\neg\CH$. To force $\CH$, we required one further instance:
%
\begin{itemize}
\item
  \isatt{replacement{\uscore}dcwit{\uscore}repl{\uscore}body{\uscore}fm}.

  Absoluteness of the recursive construction in the proof of the
  Dependent Choices from $\AC$.
\end{itemize}

The particular choice of some of the instances above arose from
Paulson's architecture on which we based our development.
This applies every time
a locale from \session{ZF-Constructible} has to be
interpreted (namely \isatt{M{\uscore}datatypes}
\isatt{M{\uscore}eclose}, and \isatt{M{\uscore}ordertype}).
%% For instance, the first
%% instance required for the definition of relative ordertypes arises
%% from Paulson's \session{ZF-Constructible}.
% https://isabelle.in.tum.de/dist/library/ZF/ZF-Constructible/Rank.html#offset_1123..1139

On the other hand, as explained in
Section~\ref{sec:zfc-axioms-as-locales}, we managed to eliminate the
instance arising from the \isatt{M{\uscore}basic} locale. Similarly,
we replaced the original proof of the Schröder-Bernstein Theorem by
Zermelo's one \cite[Exr. x4.27]{moschovakis1994notes}, because the
former required at least one extra instance
% (\isatt{banach{\uscore}iterates{\uscore}fm})
arising from an iteration.

It is to be noted that application of the Forcing Theorems do not
require any extra replacement instances on $M$ (independently of the
formula $\phi$ for which they are invoked). This is not the case for
Separation, at least from our formalization: More instances are needed
as the complexity of $\phi$ grows. One point where this is apparent is
in the proof of Theorem~\ref{th:forcing-thms}(\ref{item:truth-lemma}),
that appears as the \isatt{truth{\uscore}lemma} in our development; it
depends on \isatt{truth{\uscore}lemma'} and
\isatt{truth{\uscore}lemma{\uscore}Neg} which explicitly invoke
\isatt{separation{\uscore}ax}.

\subsection{A sample formal proof}
\label{sec:sample-formal-proof}

We present a fragment of the formal version of Kunen's proof that the
Powerset Axiom holds in a generic extension. We quote the relevant
paragraph of \cite[Thm.~IV.2.27]{kunen2011set}:
\begin{quote}
  For Power Set (similarly to Union above), it is sufficient to prove
  that whenever $a \in M[G]$, there is a $b \in M[G]$ such that
  $\mathcal{P}(a) \cap M[G] \subseteq b$. Fix $\tau \in
  M^{\mathbb{P}}$ such that $\tau_{G}=a$. Let
  $Q=(\mathcal{P}(\operatorname{dom}(\tau) \times
  \mathbb{P}))^{M}$. This is the set of all names $\vartheta \in
  M^{\mathbb{P}}$ such that $\operatorname{dom}(\vartheta) \subseteq
  \operatorname{dom}(\tau)$. Let $\pi=Q \times\{\1\}$ and let
  $b=\pi_{G}=$ $\left\{\vartheta_{G}: \vartheta \in Q\right\}$. Now,
  consider any $c \in \mathcal{P}(a) \cap M[G]$; we need to show that
  $c \in b$. Fix $\varkappa \in M^{\mathbb{P}}$ such that
  $\varkappa_{G}=c$, and let $\vartheta=\{\langle\sigma, p\rangle:
  \sigma \in \operatorname{dom}(\tau) \wedge p \Vdash \sigma \in
  \varkappa\}$; $\vartheta \in M$ by the Definability Lemma. Since
  $\vartheta \in Q$, we are done if we can show that
  $\vartheta_{G}=c$.
\end{quote}
The assumption $a\in M[G]$ appears in the lemma statement, and the
goal involving $b$ in the first sentence will appear below (signaled
by “{\small (**)}”); formalized
material necessarily tends to be much more linear than usual prose. In
what follows, we
will intersperse the relevant passages of the proof.
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse%
\ Pow{\isacharunderscore}{\kern0pt}inter{\isacharunderscore}{\kern0pt}MG{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}a{\isasymin}M{\isacharbrackleft}{\kern0pt}G{\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}Pow{\isacharparenleft}{\kern0pt}a{\isacharparenright}{\kern0pt}\ {\isasyminter}\ M{\isacharbrackleft}{\kern0pt}G{\isacharbrackright}{\kern0pt}\ {\isasymin}\ M{\isacharbrackleft}{\kern0pt}G{\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\isanewline
%
\isacommand{proof}\isamarkupfalse%
\ {\isacharminus}{\kern0pt}
\end{isabelle}
\textit{Fix $\tau \in  M^{\mathbb{P}}$ such that $\tau_{G}=a$.}
\begin{isabelle}
\ \ \isacommand{from}\isamarkupfalse%
\ assms\isanewline
\ \ \isacommand{obtain}\isamarkupfalse%
\ {\isasymtau}\ \isakeyword{where}\ {\isachardoublequoteopen}{\isasymtau}\ {\isasymin}\ M{\isachardoublequoteclose}\ {\isachardoublequoteopen}val{\isacharparenleft}{\kern0pt}G{\isacharcomma}{\kern0pt}\ {\isasymtau}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ a{\isachardoublequoteclose}\isanewline
\ \ \ \ \isacommand{using}\isamarkupfalse%
\ GenExtD\ \isacommand{by}\isamarkupfalse%
\ auto
\end{isabelle}
\textit{Let
  $Q=(\mathcal{P}(\operatorname{dom}(\tau) \times
  \mathbb{P}))^{M}$.}
\begin{isabelle}
\ \ \isacommand{let}\isamarkupfalse%
\ {\isacharquery}{\kern0pt}Q{\isacharequal}{\kern0pt}{\isachardoublequoteopen}Pow{\isacharparenleft}{\kern0pt}domain{\isacharparenleft}{\kern0pt}{\isasymtau}{\isacharparenright}{\kern0pt}{\isasymtimes}P{\isacharparenright}{\kern0pt}\ {\isasyminter}\ M{\isachardoublequoteclose}
\end{isabelle}
\textit{This is the set of all names $\vartheta \in
  M^{\mathbb{P}}$} [\dots]---it is pretty laborious to show that things
are in $M$; it takes 17 more lines of code (not shown below) that
apply further previously proved lemmas.
\begin{isabelle}
\ \ \isacommand{from}\isamarkupfalse%
\ {\isacartoucheopen}{\isasymtau}{\isasymin}M{\isacartoucheclose}\isanewline
\ \ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}domain{\isacharparenleft}{\kern0pt}{\isasymtau}{\isacharparenright}{\kern0pt}{\isasymtimes}P\ {\isasymin}\ M{\isachardoublequoteclose}\ {\isachardoublequoteopen}domain{\isacharparenleft}{\kern0pt}{\isasymtau}{\isacharparenright}{\kern0pt}\ {\isasymin}\ M{\isachardoublequoteclose}\isanewline
\ \ \ \ \isacommand{by}\isamarkupfalse%
\ simp{\isacharunderscore}{\kern0pt}all\isanewline
\ \ \isacommand{then}\isamarkupfalse%
\isanewline
\ \ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isacharquery}{\kern0pt}Q\ {\isasymin}\ M{\isachardoublequoteclose}
\end{isabelle}
[\dots]\textit{ Let $\pi=Q \times\{\1\}$ and let
  $b=\pi_{G}=$ $\left\{\vartheta_{G}: \vartheta \in Q\right\}$.}
\begin{isabelle}
\ \ \isacommand{let}\isamarkupfalse%
\ {\isacharquery}{\kern0pt}{\isasympi}{\isacharequal}{\kern0pt}{\isachardoublequoteopen}{\isacharquery}{\kern0pt}Q{\isasymtimes}{\isacharbraceleft}{\kern0pt}{\isasymone}{\isacharbraceright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isacommand{let}\isamarkupfalse%
\ {\isacharquery}{\kern0pt}b{\isacharequal}{\kern0pt}{\isachardoublequoteopen}val{\isacharparenleft}{\kern0pt}G{\isacharcomma}{\kern0pt}{\isacharquery}{\kern0pt}{\isasympi}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%% \isanewline
%% \ \ \isacommand{from}\isamarkupfalse%
%% \ {\isacartoucheopen}{\isacharquery}{\kern0pt}Q{\isasymin}M{\isacartoucheclose}\isanewline
%% \ \ \isacommand{have}\isamarkupfalse%
%% \ {\isachardoublequoteopen}{\isacharquery}{\kern0pt}{\isasympi}{\isasymin}M{\isachardoublequoteclose}\isanewline
%% \ \ \ \ \isacommand{using}\isamarkupfalse%
%% \ one{\isacharunderscore}{\kern0pt}in{\isacharunderscore}{\kern0pt}P\ P{\isacharunderscore}{\kern0pt}in{\isacharunderscore}{\kern0pt}M\ transitivity\isanewline
%% \ \ \ \ \isacommand{by}\isamarkupfalse%
%% \ {\isacharparenleft}{\kern0pt}simp\ flip{\isacharcolon}{\kern0pt}\ setclass{\isacharunderscore}{\kern0pt}iff{\isacharparenright}{\kern0pt}\isanewline
%% \ \ \isacommand{then}\isamarkupfalse%
%% \isanewline
%% \ \ \isacommand{have}\isamarkupfalse%
%% \ {\isachardoublequoteopen}{\isacharquery}{\kern0pt}b\ {\isasymin}\ M{\isacharbrackleft}{\kern0pt}G{\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\isanewline
%% \ \ \ \ \isacommand{using}\isamarkupfalse%
%% \ GenExtI\ \isacommand{by}\isamarkupfalse%
%% \ simp
\end{isabelle}
\textit{Now,
  consider any $c \in \mathcal{P}(a) \cap M[G]$; we need to show that
  $c \in b$.}
\begin{isabelle}
  \label{goal-on-b}
\ \ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}Pow{\isacharparenleft}{\kern0pt}a{\isacharparenright}{\kern0pt}\ {\isasyminter}\ M{\isacharbrackleft}{\kern0pt}G{\isacharbrackright}{\kern0pt}\ {\isasymsubseteq}\ {\isacharquery}{\kern0pt}b{\isachardoublequoteclose}\hfill
\mbox{\rm\small(**)}\isanewline
\ \ \isacommand{proof}\isamarkupfalse%
\isanewline
\ \ \ \ \isacommand{fix}\isamarkupfalse%
\ c\isanewline
\ \ \ \ \isacommand{assume}\isamarkupfalse%
\ {\isachardoublequoteopen}c\ {\isasymin}\ Pow{\isacharparenleft}{\kern0pt}a{\isacharparenright}{\kern0pt}\ {\isasyminter}\ M{\isacharbrackleft}{\kern0pt}G{\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
\textit{Fix $\varkappa \in M^{\mathbb{P}}$ such that
  $\varkappa_{G}=c$,}
\begin{isabelle}
\ \ \ \ \isacommand{then}\isamarkupfalse%
\isanewline
\ \ \ \ \isacommand{obtain}\isamarkupfalse%
\ {\isasymchi}\ \isakeyword{where}\ {\isachardoublequoteopen}c{\isasymin}M{\isacharbrackleft}{\kern0pt}G{\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\ {\isachardoublequoteopen}{\isasymchi}\ {\isasymin}\ M{\isachardoublequoteclose}\ {\isachardoublequoteopen}val{\isacharparenleft}{\kern0pt}G{\isacharcomma}{\kern0pt}{\isasymchi}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ c{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \isacommand{using}\isamarkupfalse%
\ GenExt{\isacharunderscore}{\kern0pt}iff\ \isacommand{by}\isamarkupfalse%
\ auto
\end{isabelle}
\textit{and let $\vartheta=\{\langle\sigma, p\rangle:
  \sigma \in \operatorname{dom}(\tau) \wedge p \Vdash \sigma \in
  \varkappa\}$;}
\begin{isabelle}
\ \ \ \ \isacommand{let}\isamarkupfalse%
\ {\isacharquery}{\kern0pt}{\isasymtheta}{\isacharequal}{\kern0pt}{\isachardoublequoteopen}{\isacharbraceleft}{\kern0pt}{\isasymlangle}{\isasymsigma}{\isacharcomma}{\kern0pt}p{\isasymrangle}\ {\isasymin}domain{\isacharparenleft}{\kern0pt}{\isasymtau}{\isacharparenright}{\kern0pt}{\isasymtimes}P\ {\isachardot}{\kern0pt}\ p\ {\isasymtturnstile}\ {\isasymcdot}{\isadigit{0}}\ {\isasymin}\ {\isadigit{1}}{\isasymcdot}\ {\isacharbrackleft}{\kern0pt}{\isasymsigma}{\isacharcomma}{\kern0pt}{\isasymchi}{\isacharbrackright}{\kern0pt}\ {\isacharbraceright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
\textit{$\vartheta \in M$ by the Definability Lemma.}
\begin{isabelle}
\ \ \ \ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}arity{\isacharparenleft}{\kern0pt}forces{\isacharparenleft}{\kern0pt}Member{\isacharparenleft}{\kern0pt}{\isadigit{0}}{\isacharcomma}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isadigit{6}}{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \isacommand{using}\isamarkupfalse%
\ arity{\isacharunderscore}{\kern0pt}forces{\isacharunderscore}{\kern0pt}at\ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\ \ \ \ \isacommand{with}\isamarkupfalse%
\ {\isacartoucheopen}domain{\isacharparenleft}{\kern0pt}{\isasymtau}{\isacharparenright}{\kern0pt}\ {\isasymin}\ M{\isacartoucheclose}\ {\isacartoucheopen}{\isasymchi}\ {\isasymin}\ M{\isacartoucheclose}\isanewline
\ \ \ \ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isacharquery}{\kern0pt}{\isasymtheta}\ {\isasymin}\ M{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \isacommand{using}\isamarkupfalse%
\ sats{\isacharunderscore}{\kern0pt}fst{\isacharunderscore}{\kern0pt}snd{\isacharunderscore}{\kern0pt}in{\isacharunderscore}{\kern0pt}M\isanewline
\ \ \ \ \ \ \isacommand{by}\isamarkupfalse%
\ simp
\end{isabelle}
\textit{Since
  $\vartheta \in Q$,}
\begin{isabelle}
\ \ \ \ \isacommand{then}\isamarkupfalse%
\isanewline
\ \ \ \ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isacharquery}{\kern0pt}{\isasymtheta}\ {\isasymin}\ {\isacharquery}{\kern0pt}Q{\isachardoublequoteclose}\ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\ \ \ \ \isacommand{then}\isamarkupfalse%
\isanewline
\ \ \ \ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}val{\isacharparenleft}{\kern0pt}G{\isacharcomma}{\kern0pt}{\isacharquery}{\kern0pt}{\isasymtheta}{\isacharparenright}{\kern0pt}\ {\isasymin}\ {\isacharquery}{\kern0pt}b{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \isacommand{using}\isamarkupfalse%
\ one{\isacharunderscore}{\kern0pt}in{\isacharunderscore}{\kern0pt}G\ generic\ val{\isacharunderscore}{\kern0pt}of{\isacharunderscore}{\kern0pt}elem\ {\isacharbrackleft}{\kern0pt}of\ {\isacharquery}{\kern0pt}{\isasymtheta}\ {\isasymone}\ {\isacharquery}{\kern0pt}{\isasympi}\ G{\isacharbrackright}{\kern0pt}\isanewline
\ \ \ \ \ \ \isacommand{by}\isamarkupfalse%
\ auto
\end{isabelle}
\textit{we are done if we can show that
  $\vartheta_{G}=c$.}
\begin{isabelle}
\ \ \ \ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}val{\isacharparenleft}{\kern0pt}G{\isacharcomma}{\kern0pt}{\isacharquery}{\kern0pt}{\isasymtheta}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ c{\isachardoublequoteclose}
\end{isabelle}

Undoubtedly, even for this cherry-picked example, the formalization
looks codish. It is therefore inevitable to compare this to the
magnificent results obtained by P.~Koepke and his team by using
Isabelle/Naproche \cite{10.1007/978-3-030-81097-9_2} (notoriously,
König's Theorem). The trick there consists in presenting the result
being formalized as restricted first-order problem, and then each
proof step can be handled by an automatic theorem prover.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "independence_ch_isabelle"
%%% ispell-local-dictionary: "american"
%%% End: 
