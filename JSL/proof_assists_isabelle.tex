\section{Proof assistants and Isabelle/ZF}
\label{sec:proof-assist-isabelle}

Proof assistants provide diverse aids for the task
of formalizing a piece of mathematics. They are usually implemented
using a typed programming language; rigor is enforced by defining a
type of ``theorems'', whose members can only be constructed using
operations stipulated in a small \emph{kernel} which encodes the
underlying foundation of the assistant. Further developments interact
with the type of theorems only through the kernel, and thus the latter
is the only ``trusted'' part of the assistant's code.

Several of the more established assistants (HOL Light, Coq, Isabelle)
are programmed in some variant of the ML language (which was
designed for this purpose); the newer Lean, on the other
hand, was originally conceived as a standalone functional programming
language with all the features of a standard assistant.

\subsection{Four layers}

In the case of Isabelle, Standard ML is the deeper layer of the
assistant, in which the kernel is written.

The logical foundation of Isabelle is an intuitionistic fragment of
higher-order logic (or simple type theory) called $\Meta$;
original version was described in \cite{Paulson1989}, and the addition
of  sorts appears in \cite{Nipkow-LF-91}.

The only predefined type is $\prop$ (“propositions”); new base types
can be postulated when defining objects logics. Types of higher order can be
assembled using the function space constructor $\fun$.

The type of propositions $\prop$ equipped with a binary operation
$\implies$ (“meta-implication”) that is used to represent the object
logic rules. As an example, the axiomatization of first-order logic
postulates a type $\tyo$ of booleans, and Modus Ponens
% https://isabelle.in.tum.de/dist/library/FOL/FOL/IFOL.html#IFOL.mp|axiom
is written as
\[
  [P\limp Q] \implies ([P] \implies [Q]).
\]
The square brackets represent an injection from $\tyo$ into
$\prop$. % ($[P]$ can be read as “$P$ holds”)
A consequence of this representation is that every
formula of the object logic appears as atomic for $\Meta$.

%% Quantification is handled in the meta-level using a functional $\ALL$
%% with polymorphic type $(\alpha \fun \prop) \fun \prop$. 
Types in Isabelle are organized into \emph{classes} and \emph{sorts};
for ease of exposition, we will omit the former.  The axiomatization
of first-order logic postulates a sort $\type{term}$ (of
“individuals”, or elements of a first-order universe of discourse) and
stipulates that every further type variable $\alpha$ must be of that
sort. In particular, Isabelle/ZF only postulates one new type $\tyi$
(“sets”) of sort $\type{term}$. Hence, from the type of the universal
quantifier functional $\forall :: (\alpha \fun \tyo) \fun \tyo$ it
follows that it may only be applied to predicates with a variable of
type $\tyi$. This ensures that the object logic is effectively
first-order.

Paulson  \cite{Paulson1989} carried out a proof that the encoding
$\Meta_{\mathrm{IFOL}}$ of
intuitionistic first-order logic without equality in the original $\Meta$ is
conservative (there is a correspondence between provable $\phi$ in
IFOL and provable $[\phi]$ in $\Meta_{\mathrm{IFOL}}$) by putting
$\Meta_{\mathrm{IFOL}}$ proofs in \emph{expanded normal form}
\cite{MR0387024}. Passing to classical logic does not presents
difficulties, but the treatment of meta-equality differs between the
original and the present incarnation of $\Meta$; details are
exhaustively expounded in the recent formalization by Nipkow and
Roßkof \cite{10.1007/978-3-030-79876-5_6}.


%% Isabelle \cite{Isabelle,DBLP:books/sp/Paulson94} is a general proof
%% assistant based on fragment of higher-order logic called
%% \emph{Pure}. 
%% The results presented in this work are theorems of a
%% version of $\ZF$ set theory (without the Axiom of Choice, $\AC$) 
%% called \emph{Isabelle/ZF}, which is one of the
%% ``object logics'' that can be defined on top of Pure (which is then
%% used as a language to define rules). Isabelle/ZF defines types
%% \isatt{i} and \isatt{o} for sets and Booleans, resp., and the $\ZF$
%% axioms are written down as terms of type \isatt{o}.
%% 
%% It should be noted that Pure is a very weak framework and has no
%% induction/recursion capabilities. So the only way to define functions
%% by recursion is inside the object logic. (This works the same for
%% Isabelle/HOL.) For this reason, to define the relation of forcing, we
%% needed to resort to \emph{internalized} first-order formulas: they
%% form a recursively defined set \isatt{formula}. For example, the
%% predicate of satisfaction
%% \isatt{sats::i{\isasymRightarrow}i{\isasymRightarrow}i{\isasymRightarrow}o}
%% (written $M,\mathit{ms}\models\phi$ for a set $M$,
%% $\mathit{ms}\in\isatt{list}(M)$ and $\phi\in\formula$)
%% had already been defined by recursion in Paulson~\cite{paulson_2003}.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "independence_ch_isabelle"
%%% ispell-local-dictionary: "american"
%%% End: 
